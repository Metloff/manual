# Gready algorithms (жадные алгоритмы)

Понятие жадности хорошо проиллюстрировать на примере задачи о рюкзаке.

> Вор забирается в ювелирный магазин с мешком, вместимостью M килограмм. Каждое ювелирное изделие стоит ci$ и имеет вес mi. Задача вора — собрать мешок с максимальным весом.

У этой задачи существует два разных вида — в первом случае вор может либо взять каждое изделие либо нет, а во втором, ценность ювелирной работы не очень важна, а важен только драгоценный метал, и вор может отпилить кусок изделия, не влезающий в мешок. Первая вариация известна как задача о дискретном рюкзаке, а вторая — как задача о непрерывном рюкзаке.

На первый взгляд, задачи эти отличаются незначительно. Но построив полиномиальный алгоритм для первой, вы получите $1 000 000 от института Клэя за решение задачи тысячелетия: вы докажете, что P = NP, решив NP-полную задачу (о рюкзаке). P и NP — это два класса задач: первый класс состоит из задач, разрешимых полиномиальным алгоритмом, а второй — из задач, проверяемых за полиномиальное время. Если  кто-то очень умный сообщит вору какие вещи ему брать, чтобы набить рюкзак лучшим способом, то вор сможет это проверить. Обращаем внимание, что задачи
из NP класса достаточно естественны и многие из них никто не умеет решать за полиномиальное время.

Жадный алгоритм, решающий непрерывную версию задачи о рюкзаке кратко звучит так: 

>вору нужно отсортировать драгоценности по их удельной стоимости `ρi = ci/mi` и класть в мешок в первую очередь те драгоценности, удельная стоимость которых больше ещё не взятых. Если место в рюкзаке ещё осталось, а самый ценный на данном шаге предмет в него не влезает, то его нужно распилить и поместить в мешок влезающий в него кусок. 

Неформально, алгоритм называется жадным, если для него выполняется принцип «дают бери, а бьют — беги» как в примере с вором. Чуть более формально, жадный алгоритм на каждом шаге ищет локально-оптимальное решение и в итоге приходит к глобальному оптимуму.