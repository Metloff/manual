# [Реляционные БД](https://en.wikipedia.org/wiki/Relational_database#RDBMS) 

Базы данных, основанные на реляционной модели данных. Одни из самых популярных баз данных.

- [Масштабирование](scaling/README.md)
- [<- назад](README.md)

**Плюсы**
- Планировщик запроса
- Хорошая поддержка связи "многие ко многим"
  
**Примеры**

Oracle, MySQL (free software), Microsoft SQL Server, PostgreSQL (free software), IBM DB2, Microsoft Access, SQLite (free software), and MariaDB (free software).
  
# Нормализация 
Процесс разбиения данных на таблицы, связанные друг с другом отношениями.

Бонусы:
- Упрощение системы
- Уменьшение количества ошибок
- Устранение избыточности данных
- Уменьшение размера БД
- Устранение несогласованных зависимостей
- Защита данных от случайного удаления (констрейнты и тд)
  
Минусы:
- Усложнение запросов (как селектов со множеством джоинов, так и удалений/вставок которые приводят к апдейту сразу ряда таблиц)

# Денормализация
Обратный нормализации процесс. Мы копируем горячие данные либо предрасчитываем их(количество непрочитанных сообщений в чате).

Плюсы:
- Ускоряем процесс выборки (быстро выполняемые селекты)
- Упрощаем процесс выборки (быстро и легко писать селекты)
  
Минусы:
- Дорогие запросы создания/удаления/обновления (если необходимо делать перерасчеты каких то величин)
- Повышение сложности вставок/удаления/обновления (если необходимо делать перерасчеты)


# Индексы

Дополнительные структуры, которые строятся на основе данных таблицы, которые ускоряют поиск. Также индексы часто используются для обеспечения целостности базы данных (уникализации значений и тд).

Индекс должен обладать высокой селективностью (указывать на маленькое количество данных), иначе он будет плохо работать.

Индексы налагают оверхед на вставку/апдейт, поэтому много индексов - плохо.

**Виды индексов**

- B-tree индекс (сбалансированное дерево)

# Транзакции
Транзакция - группа последовательных операций с базой данных, которая представляет собой логическую единицу работы с данными. Транзакция может быть выполнена либо целиком и успешно, соблюдая целостность данных и независимо от параллельно идущих других транзакций, либо не выполнена вообще, и тогда она не должна произвести никакого эффекта.

## ACID
Требования к транзакционной системе (СУБД), обеспечивающие надежную и предсказуемую ее работу.

**Atomicity(Атомарность)**

Атомарность гарантирует, что никакая транзакция не будет выполнена частично. Либо применятся все изменения - либо ни одного. Если транзакцию не удается выполнить до конца, результаты всех ее изменений будут отменены.

**Consistency(Согласованность)**

Завершившаяся транзакция должна сохранять согласованность базы данных. Это бизнес требование к программистам, нежели требование к СУБД.

Например, в банковской системе может существовать требование равенства суммы, списываемой с одного счёта, сумме, зачисляемой на другой. Это бизнес-правило и оно не может быть гарантировано только проверками целостности, его должны соблюсти программисты при написании кода транзакций. Если какая-либо транзакция произведёт списание, но не произведёт зачисления, то система останется в некорректном состоянии и свойство согласованности будет нарушено.

**Isolation(Изоляция)**

Паралельно выполняющиеся транзакции не должны оказывать влияние на текущую транзакцию. Изолированность — требование дорогое, поэтому в реальных БД существуют режимы, не полностью изолирующие транзакцию (уровни изолированности Repeatable Read и ниже).

**Durability(Стойкость)**

Изменения, сделанные успешно завершенной транзакцией, должны остаться сохраненными после возвращения системы в работу, вне зависимости от проблем на нижних уровнях (к примеру, обесточивание системы или сбои в оборудовании). Другими словами, если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя.

## [Проблемы паралельной работы с данными](https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9)

**Потерянное обновление (lost update)**

Потеря данных при одновременном коммите двух транзакций. Например когда два человека пытаются одновременно забронировать переговорку/купить билет. В таком переговорка и билет могут достаться пользователю, чья транзакция была применена последней. Стоит отметить, что в этом примере идет речь об обычном апдейте, без дополнительных селектов. Дополнительные селекты усложняют проблему и скорее относятся к *Неповторяющееся чтение*.

*Потерянное обновление:* `UPDATE films SET did = 1 WHERE did = 0`
*Неповторяющееся чтение:* `UPDATE films SET did = 1 WHERE code = (SELECT code FROM films WHERE did = 0);` 

Еще пример:

Ситуация, когда при одновременном изменении одного блока данных разными транзакциями одно из изменений теряется.

Предположим, имеются две транзакции, выполняемые одновременно:

Транзакция 1 | Транзакция 2 
--- | --- 
`UPDATE tbl1 SET f2=f2+20 WHERE f1=1;` | `UPDATE tbl1 SET f2=f2+25 WHERE f1=1;`

В обеих транзакциях изменяется значение поля f2, по их завершении значение поля должно быть увеличено на 45. В действительности может возникнуть следующая последовательность действий:

- Обе транзакции одновременно читают текущее состояние поля. Точная физическая одновременность здесь не обязательна, достаточно, чтобы вторая по порядку операция чтения выполнилась до того, как другая транзакция запишет свой результат.
- Обе транзакции вычисляют новое значение поля, прибавляя, соответственно, 20 и 25 к ранее прочитанному значению.
Транзакции пытаются записать результат вычислений обратно в поле f2. Поскольку физически одновременно две записи выполнить невозможно, в реальности одна из операций записи будет выполнена раньше, другая позже. При этом вторая операция записи перезапишет результат первой.
- В результате значение поля f2 по завершении обеих транзакций может увеличиться не на 45, а на 20 или 25, то есть одна из изменяющих данные транзакций «пропадёт».

**Грязное чтение (dirty read)**

Когда одна транзакция видит и использует непримененные (незакомиченные) данные других транзакций, которые могут быть в последствии откачены (произойдет rollback).

**Неповторяющееся чтение (non-repeatable read)**

При повторном чтении в рамках одной и той же транзакции, ранее прочитанные данные оказываются измененными (другой транзакцией которая произошла быстрее).

**Фантомное чтение (phantom reads)**

Ситуация, когда при повторном чтении в рамках одной транзакции одна и та же выборка дает разные множества строк.

Предположим, имеется две транзакции, открытые различными приложениями, в которых выполнены следующие SQL-операторы:

Транзакция 1 | Транзакция 2 
--- | --- 
none | `SELECT SUM(f2) FROM tbl1;` 
`INSERT INTO tbl1 (f1,f2) VALUES (15,20);`|  none 
`COMMIT;` |  none
 none |  `SELECT SUM(f2) FROM tbl1;` 


В транзакции 2 выполняется SQL-оператор, использующий все значения поля f2. Затем в транзакции 1 выполняется вставка новой строки, приводящая к тому, что повторное выполнение SQL-оператора в транзакции 2 выдаст другой результат. Такая ситуация называется чтением фантома (фантомным чтением). От неповторяющегося чтения оно отличается тем, что результат повторного обращения к данным изменился не из-за изменения/удаления самих этих данных, а из-за появления новых (фантомных) данных.

## [Уровни изоляции](https://ru.wikipedia.org/wiki/%D0%A3%D1%80%D0%BE%D0%B2%D0%B5%D0%BD%D1%8C_%D0%B8%D0%B7%D0%BE%D0%BB%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D0%BE%D1%81%D1%82%D0%B8_%D1%82%D1%80%D0%B0%D0%BD%D0%B7%D0%B0%D0%BA%D1%86%D0%B8%D0%B9)

Под «уровнем изоляции транзакций» понимается степень обеспечиваемой внутренними механизмами СУБД (то есть не требующей специального программирования) защиты от всех или некоторых видов вышеперечисленных несогласованности данных, возникающих при параллельном выполнении транзакций. Стандарт SQL-92 определяет шкалу из четырёх уровней изоляции: Read uncommitted, Read committed, Repeatable read, Serializable. Первый из них является самым слабым, последний — самым сильным, каждый последующий включает в себя все предыдущие.

**Read uncommited (чтение незафиксированных данных)**

Низший (первый) уровень изоляции. Он гарантирует только отсутствие потерянных обновлений. Если несколько параллельных транзакций пытаются изменять одну и ту же строку таблицы, то в окончательном варианте строка будет иметь значение, определенное всем набором успешно выполненных транзакций. При этом возможно считывание не только логически несогласованных данных, но и данных, изменения которых ещё не зафиксированы.

Типичный способ реализации данного уровня изоляции — блокировка данных на время выполнения команды изменения, что гарантирует, что команды изменения одних и тех же строк, запущенные параллельно, фактически выполнятся последовательно, и ни одно из изменений не потеряется. Транзакции, выполняющие только чтение, при данном уровне изоляции никогда не блокируются.

*Плюсы*: Обновления не теряются

*Минусы*: Возможно чтение несогласованных и не закомиченных данных

Невозможны: 
- потерянные изменения (lost changes) 
   
Возможны:
- грязное чтение 
- неповторяемое чтение  
- чтение фантомов

Пример: Дебаг (запуск запроса на чтение в таком режиме, для того, чтобы проверить на каком этапе находится другой долгий запрос)

**Read commited (чтение фиксированных данных)**

Дефолтный уровень изоляции для большинства реляционных СУБД (PostrgeSQL, Oracle, Microsoft SQL). Этот уровень изоляции защищает от грязного чтения, но не спасает от работы с неактуальными данными, если другая транзакция(или просто запрос) изменила прочитанные нашей транзакцией данные и завершилась первее.

Например если мы получили из базы список незанятых комнат, то прочитанная нами информация может быть в следующий момент изменена другой транзакцией, но мы об этом уже не узнаем, и будем продолжать свои действия, основываясь на информации из нашего первоначального селекта.

Невозможны:
- потерянные изменения (lost changes)
- грязное чтение

Возможны:
- неповторяемое чтение
- чтение фантомов

**Repitable read (повторяющееся чтение)**

Запрещает транзакциям изменять строки, считанные в другой незавершенной транзакции, что позволяет нам избежать "неповторяющегося чтения". Данные считанные транзакцией не изменятся до ее завершения.

Однако, данный уровень изоляции не запрещает вставку новых строк.

Из-за ограничений, данный уровень изоляции имеет намного меньший уровень параллелизма, по сравнению с **Read commited**. Поэтому этот и следующий уровень советуется использовать с умом.

Невозможны:
- потерянные изменения (lost changes)
- грязное чтение
- неповторяемое чтение

Возможны:
- чтение фантомов

**Serializable (упорядочиваемость)**

Самый высокий уровень изолированности; транзакции полностью изолируются друг от друга, каждая выполняется так, как будто параллельных транзакций не существует. Только на этом уровне параллельные транзакции не подвержены эффекту «фантомного чтения».

На данном уровне изоляции происходит полная блокировка таблицы на запись/изменение, что позволяет нам избавиться и от фантомных чтений тоже.

# Доступность БД

Есть множество проблем, которые могут повлечь за собой недоступность БД (проблемы с сетью, проблемы с самой бд, отключение питания и т.д.). Поэтому, для повышения доступность применяют ряд мер:

## Репликация

Это дублирование БД (на другие узлы, серверы). Используется в большей мере для резервирования (отказоустойчивости) баз данных (чтобы не проебать данные) и в меньшей для масштабирования.

**Плюсы:**
- повышение отказоустойчивости системы. При недоступности одной бд, мы можем перевести трафик на другую реплику.
- геораспределение. При создании реплик, которые распределены географически (в других городах/странах/материках) мы защищаемся не только от проблем, которые могут возникнуть непосредственно в этом географическом месте (цунами, наводнения, революции), так и ускоряем ответ приложения пользователю, который находится далеко.
- распределение нагрузки (писать в одну реплику, читать с других)
  
**Виды реплик**

*Master/Slave реплики*

Обычно выделяют Master и Slave. В мастер приходят все изменения, он записывает в журнал изменений и этот журнал отправляет слейвам.
Слейв не принимает изменения от пользователя, а только применяет изменения, пришедшие от мастера.

Слейвы бывают синхронными и асинхронными. Мастер, посылая изменения в синхронный слейв, дожидается подтверждения о принятии изменений от него. В случае с асинхронным слейвом, мастер подтверждения не дожидается.

Синхронный слейв может немного отставать от мастера по актуальности данных. Это связанно с тем, что на применение журнала изменений требуется какое-то время. Асинхронная же реплика отстает еще больше.

В такой иерархии как правило делают по одному мастеру и синхронному слеву и n-штук ассинхронных реплик. Больше синхронных реплик = больше времени на кажду транзакцию (т.к. необходимо дожидать подтверждения от синхронной реплики подтверждения) + вероятность отката всей транзакции, если одна из синхронных реплик не ответила положительно.

*Ручная репликация (Реплики без главного узла)*

Логика реплицирования находится на клиенте. Клиент отправляет запрос сразу на большинство реплик. В случае конфликта данных, либо отсутсвия более поздних изменений на части реплик, клиент сам разрешает конфликты и обновляет реплики (если такой функционал не встроен в БД).

**Итог**
- Отказоустойчивость и высокая доступность
- Масштабирование чтения
- Независимое (и не мешающее) выполнение OLAP запросов
- Возможен лаг при чтении из sync реплики и почти точно есть лаг при чтении из async реплики



# РАЗОБРАТЬ:
- Виды локов (NOWAIT, SKIP LOCKED)

`SELECT ...FOR UPDATE`
Накладывает лок на изменения для выбранных строк (пока идет транзакция). Чтение таких строк с выставленным FOR UPDATE - ом тоже не пройдет. Операция становится в ожидание. Причем вы можете пытаться изменить 10 строк, из которых только одна залочена - все равно операция встанет в ожидание.

*Подготовим данные для эксперимента*

`CREATE TABLE distributors 
(                                                         
did    integer PRIMARY KEY, 
name   varchar(40) NOT NULL CHECK (name <> '')
);`

`insert into distributors (did, name) VALUES(1, 'one')`

`insert into distributors (did, name) VALUES(2, 'two')`

*В первом подключении к БД начнем транзакцию*

`BEGIN;
select * from distributors where did = 1 for update;`

*Во втором попытаемся выполнить команды:*

`select * from distributors for update;`

приводит к ожиданию

`UPDATE distributors SET name = 'kek' WHERE did = 1;`

приводит к ожиданию

`select * from distributors;`

успешно проходит

`UPDATE distributors SET name = 'kek';`

приводит к ожиданию

Ожиданием можноу правлять с помощью скипов (SKIP LOCKED например)
- Виды индексов
- Партиционирование
- Шардирование